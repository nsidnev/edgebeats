# AUTOGENERATED: DO NOT MODIFY
# Generated by Elixir client for EdgeDB via `mix edgedb.generate` from
#   `test/support/edgeql/insert_song.edgeql`.
defmodule Tests.EdgeDB.InsertSong do
  @query """
  with song := (
    insert Song {
      title := <str>$title,
      attribution := <optional str>$attribution,
      artist := <str>$artist,
      duration := <optional duration>$duration,
      position := <optional int64>$position ?? 0,
      status := <SongStatus>$status,
      server_ip := <optional inet>$server_ip,
      played_at := <optional datetime>$played_at,
      paused_at := <optional datetime>$paused_at,
      date_recorded := <optional cal::local_datetime>$date_recorded,
      date_released := <optional cal::local_datetime>$date_released,
      user := (select User filter .id = <optional uuid>$user_id),
      mp3 := (insert MP3 {
        url := <str>$mp3_url,
        filename := <str>$mp3_filename,
        filepath := <str>$mp3_filepath,
        filesize := <cfg::memory>$mp3_filesize,
      })
    }
  )
  select song {
    **
  }
  """

  @moduledoc """
  Generated module for the EdgeQL query from
    `test/support/edgeql/insert_song.edgeql`.

  Query:

  ```edgeql
  #{@query}
  ```
  """

  @typedoc """
  ```edgeql
  std::uuid
  ```
  """
  @type uuid() :: binary()

  @typedoc """
  ```edgeql
  std::duration
  ```
  """
  @type duration() :: Timex.Duration.t() | integer()

  @typedoc """
  ```edgeql
  scalar type default::SongStatus extending enum<stopped, playing, paused>
  ```
  """
  @type default__song_status() :: String.t() | :stopped | :playing | :paused

  @typedoc """
  ```edgeql
  scalar type default::inet extending std::bytes
  ```
  """
  @type default__inet() :: bitstring()

  @typedoc """
  ```edgeql
  scalar type default::cistr extending std::str
  ```
  """
  @type default__cistr() :: String.t()

  @type result() :: %{
          artist: String.t(),
          title: String.t(),
          attribution: String.t() | nil,
          date_recorded: NaiveDateTime.t() | nil,
          date_released: NaiveDateTime.t() | nil,
          paused_at: DateTime.t() | nil,
          played_at: DateTime.t() | nil,
          server_ip: default__inet() | nil,
          id: uuid(),
          position: integer(),
          inserted_at: NaiveDateTime.t(),
          updated_at: NaiveDateTime.t(),
          status: default__song_status(),
          duration: duration(),
          user:
            %{
              username: String.t(),
              email: default__cistr(),
              profile_tagline: String.t() | nil,
              avatar_url: String.t() | nil,
              external_homepage_url: String.t() | nil,
              id: uuid(),
              songs_count: integer(),
              inserted_at: NaiveDateTime.t(),
              updated_at: NaiveDateTime.t(),
              name: String.t()
            }
            | nil,
          mp3: %{
            id: uuid(),
            filename: String.t(),
            filepath: String.t(),
            filesize: EdgeDB.ConfigMemory.t(),
            url: String.t()
          }
        }

  @type keyword_args() :: [
          {:title, String.t()}
          | {:attribution, String.t() | nil}
          | {:artist, String.t()}
          | {:duration, duration() | nil}
          | {:position, integer() | nil}
          | {:status, default__song_status()}
          | {:server_ip, default__inet() | nil}
          | {:played_at, DateTime.t() | nil}
          | {:paused_at, DateTime.t() | nil}
          | {:date_recorded, NaiveDateTime.t() | nil}
          | {:date_released, NaiveDateTime.t() | nil}
          | {:user_id, uuid() | nil}
          | {:mp3_url, String.t()}
          | {:mp3_filename, String.t()}
          | {:mp3_filepath, String.t()}
          | {:mp3_filesize, EdgeDB.ConfigMemory.t()}
        ]

  @type map_args() :: %{
          title: String.t(),
          attribution: String.t() | nil,
          artist: String.t(),
          duration: duration() | nil,
          position: integer() | nil,
          status: default__song_status(),
          server_ip: default__inet() | nil,
          played_at: DateTime.t() | nil,
          paused_at: DateTime.t() | nil,
          date_recorded: NaiveDateTime.t() | nil,
          date_released: NaiveDateTime.t() | nil,
          user_id: uuid() | nil,
          mp3_url: String.t(),
          mp3_filename: String.t(),
          mp3_filepath: String.t(),
          mp3_filesize: EdgeDB.ConfigMemory.t()
        }

  @type args() :: map_args() | keyword_args()

  @doc """
  Run the query.
  """
  @spec query(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) ::
          {:ok, result()}
          | {:error, reason}
        when reason: any()
  def query(client, args, opts \\ []) do
    do_query(client, args, opts)
  end

  @doc """
  Run the query.
  """
  @spec query!(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) :: result()
  def query!(client, args, opts \\ []) do
    case do_query(client, args, opts) do
      {:ok, result} ->
        result

      {:error, exc} ->
        raise exc
    end
  end

  @schema [
    :updated_at,
    :title,
    :status,
    :server_ip,
    :position,
    :played_at,
    :paused_at,
    :inserted_at,
    :id,
    :duration,
    :date_released,
    :date_recorded,
    :attribution,
    :artist,
    user: [
      :username,
      :updated_at,
      :songs_count,
      :profile_tagline,
      :name,
      :inserted_at,
      :id,
      :external_homepage_url,
      :email,
      :avatar_url
    ],
    mp3: [:url, :id, :filesize, :filepath, :filename]
  ]
  defp do_query(client, args, opts) do
    opts = Keyword.merge(opts, __transform_result__: [schema: @schema])
    EdgeDB.query_required_single(client, @query, args, opts)
  end
end

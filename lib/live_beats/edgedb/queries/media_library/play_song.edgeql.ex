# AUTOGENERATED: DO NOT MODIFY
# Generated by Elixir client for EdgeDB via `mix edgedb.generate` from
#   `priv/edgedb/edgeql/media_library/play_song.edgeql`.
defmodule LiveBeats.EdgeDB.MediaLibrary.PlaySong do
  @query """
  with
    stopped_songs := (
      update Song
      filter
        .status in {SongStatus.playing, SongStatus.paused} and .id != <uuid>$song_id
      set {
        status := SongStatus.stopped
      }
    ),
    playing_song := (
      update Song
      filter .id = <uuid>$song_id
      set {
        status := SongStatus.playing
      }
    )
  select playing_song {
    *,
    mp3: {
      *
    },
    user: {
      id,
    }
  }
  """

  @moduledoc """
  Generated module for the EdgeQL query from
    `priv/edgedb/edgeql/media_library/play_song.edgeql`.

  Query:

  ```edgeql
  #{@query}
  ```
  """

  @typedoc """
  ```edgeql
  std::uuid
  ```
  """
  @type uuid() :: binary()

  @typedoc """
  ```edgeql
  std::duration
  ```
  """
  @type duration() :: Timex.Duration.t() | integer()

  @typedoc """
  ```edgeql
  scalar type default::SongStatus extending enum<stopped, playing, paused>
  ```
  """
  @type default__song_status() :: String.t() | :stopped | :playing | :paused

  @typedoc """
  ```edgeql
  scalar type default::inet extending std::bytes
  ```
  """
  @type default__inet() :: bitstring()

  @type result() ::
          %{
            mp3: %{
              id: uuid(),
              filename: String.t(),
              filepath: String.t(),
              filesize: EdgeDB.ConfigMemory.t(),
              url: String.t()
            },
            user: %{id: uuid()} | nil,
            artist: String.t(),
            title: String.t(),
            attribution: String.t() | nil,
            date_recorded: NaiveDateTime.t() | nil,
            date_released: NaiveDateTime.t() | nil,
            paused_at: DateTime.t() | nil,
            played_at: DateTime.t() | nil,
            server_ip: default__inet() | nil,
            id: uuid(),
            position: integer(),
            inserted_at: NaiveDateTime.t(),
            updated_at: NaiveDateTime.t(),
            status: default__song_status(),
            duration: duration()
          }
          | nil

  @type keyword_args() :: [{:song_id, uuid()}]

  @type map_args() :: %{
          song_id: uuid()
        }

  @type args() :: map_args() | keyword_args()

  @doc """
  Run the query.
  """
  @spec query(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) ::
          {:ok, result()}
          | {:error, reason}
        when reason: any()
  def query(client, args, opts \\ []) do
    do_query(client, args, opts)
  end

  @doc """
  Run the query.
  """
  @spec query!(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) :: result()
  def query!(client, args, opts \\ []) do
    case do_query(client, args, opts) do
      {:ok, result} ->
        result

      {:error, exc} ->
        raise exc
    end
  end

  @schema [
    :updated_at,
    :title,
    :status,
    :server_ip,
    :position,
    :played_at,
    :paused_at,
    :inserted_at,
    :id,
    :duration,
    :date_released,
    :date_recorded,
    :attribution,
    :artist,
    user: [:id],
    mp3: [:url, :id, :filesize, :filepath, :filename]
  ]
  defp do_query(client, args, opts) do
    opts = Keyword.merge(opts, __transform_result__: [schema: @schema])
    EdgeDB.query_single(client, @query, args, opts)
  end
end
